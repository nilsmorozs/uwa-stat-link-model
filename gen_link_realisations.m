% This script is used to synthesise random link realisations 
% using the statistical model generated by the 'gen_link_model.m' script

% This script is used to process the ASUNA Werbellin lake dataset 
% and generate statistical link models as described in the paper

% Copyright 2024 Nils Morozs, University of York (nils.morozs@york.ac.uk)
%
% Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
% associated documentation files (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge, publish, distribute,
% sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in all copies or substantial
% portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
% NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
% OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%% Import the model
load('on_off_dur_model_werbellin16.mat');

%% Generate link ON/OFF state durations from the empirical CDF model

num_links = 6; % number of link realisations to generate
link_types = [1, 1, 2, 2, 3, 3]; % 1 - good, 2 - average, 3 - poor
num_states = 2; % ON & OFF
max_duration = 600; % sec
state_switch_times = cell(1, num_links);

% For every link type and state, use the empirical distribution to generate random durations
for n = 1:num_links

    % Initialise the state switch time vector: ON state at zero time
    state_switch_times{n} = 0;

    % While we have not reached the specified maximum duration, keep generating ON/OFF state transitions
    while (state_switch_times{n}(end) <= max_duration)

        % For the ON and OFF state
        for k = 1:num_states
    
            % Pick the corresponding empirical CDF
            if (k == 1)
                dur_vals = on_off_dur_model{link_types(n)}.on_dur_vals;
                prc_vals = on_off_dur_model{link_types(n)}.on_prc_vals;
            else
                dur_vals = on_off_dur_model{link_types(n)}.off_dur_vals;
                prc_vals = on_off_dur_model{link_types(n)}.off_prc_vals;
            end
    
            % Generate random state duration according to the empirical CDF and add it to the vector
            rand_num = rand;
            state_dur = interp1(prc_vals, dur_vals, rand_num, 'linear');
            state_switch_times{n} = [state_switch_times{n}, state_switch_times{n}(end) + state_dur];
        end
    end
end

%% Plot the link ON-OFF state timelines
figure; hold on;
y_pos = [18, 15, 10, 7, 2, -1]; % Y positions for the link timelines
styles = {'k-', 'k-', 'b-', 'b-', 'm-', 'm-'};

% Plot every link timeline in its Y position on the plot
for n = 1:num_links

    x_vect = NaN(1, numel(state_switch_times{n})*2);
    y_vect = NaN(1, numel(state_switch_times{n})*2);
    curr_state = 0;
    for k = 1:numel(state_switch_times{n})
        x_vect(2*(k-1)+1) = state_switch_times{n}(k);
        x_vect(2*(k-1)+2) = state_switch_times{n}(k);
        if (k == 1)
            y_vect(2*(k-1)+1) = y_pos(n)+0.5;
        else
            y_vect(2*(k-1)+1) = y_pos(n)-0.5+curr_state;
        end
        % Switch state
        curr_state = mod(curr_state+1, 2);
        y_vect(2*(k-1)+2) = y_pos(n)-0.5+curr_state;
    end

    % Plot it
    plot(x_vect, y_vect, styles{n});

end

% Format the plot
axis([0, max_duration, -2, 21]);
box on; grid on;
xlabel('Time, sec');
yticks(sort([y_pos-0.5, y_pos+0.5]));
yticklabels({'OFF', 'ON', 'OFF', 'ON', 'OFF', 'ON', 'OFF', 'ON', 'OFF', 'ON', 'OFF', 'ON'})
